# CHECKAWARDS
@bot.slash_command(name="check_awards", description="Check awards to ensure everyone is up-to-date")
@option("target_role", description="Select the role to check! Ships and squads work best.")
async def check_awards(ctx, target_role: discord.Role = None):
    logging.info(f"check_awards command invoked by {ctx.author.display_name}")
    await ctx.defer(ephemeral=True)

    async def process_member(member):
        try:
            # Fetch subclass points from the database
            subclass_points = db_manager.get_subclass_points(member.id)
            # Set default points for subclasses if no data is found
            points = {
                "carpenter": subclass_points.get("carpenter", 0),
                "flex": subclass_points.get("flex", 0),
                "cannoneer": subclass_points.get("cannoneer", 0),
                "helm": subclass_points.get("helm", 0),
                "grenadier": subclass_points.get("grenadier", 0),
                "surgeon": subclass_points.get("surgeon", 0)
            }

            # Function to get the appropriate role based on points
            def get_role(subclass, points):
                thresholds = {
                    "carpenter": (5, 15, 25),
                    "flex": (5, 15, 25),
                    "cannoneer": (5, 15, 25),
                    "helm": (5, 15, 25),
                    "grenadier": (10,),
                    "surgeon": (5,)
                }

                titles = ["Adept", "Pro", "Master"]
                subclass_thresholds = thresholds.get(subclass, ())
                for i, threshold in enumerate(subclass_thresholds):
                    if points >= threshold:
                        return f"{titles[i]} {subclass.capitalize()}"
                if subclass == "grenadier" and points >= 10:
                    return "Grenadier"
                if subclass == "surgeon" and points >= 5:
                    return "Field Surgeon"
                return None

            # Determine missing roles
            required_roles = {subclass: get_role(subclass, points[subclass]) for subclass in points}
            user_roles = {role.name for role in member.roles}
            missing_roles = [
                f"<@{member.id}> is missing the {role}"
                for subclass, role in required_roles.items()
                if role and role not in user_roles
            ]

            return "\n".join(missing_roles)
        except Exception as e:
            logging.error(f"Error processing member {member.display_name}: {e}")
            return f"Error processing member {member.display_name}: {e}"

    try:
        missing_roles_list = []
        if target_role:
            for member in target_role.members:
                missing_roles_list.append(await process_member(member))
        else:
            missing_roles_list.append(await process_member(ctx.author))

        missing_roles = "\n".join(filter(None, missing_roles_list))  # Filter out empty strings

        if missing_roles:
            await ctx.respond(missing_roles, ephemeral=True)
        else:
            await ctx.respond("All awards are up-to-date.", ephemeral=True)
    except Exception as e:
        logging.error(f"Error in check_awards command: {e}")
        await ctx.respond("An error occurred while checking awards. Please try again later.", ephemeral=True)

